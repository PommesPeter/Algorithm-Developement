# Chapter1 Basic Algorithm

## 排序
### quicksort(快速排序)
> 一般现场手写的会考
#### 算法流程
1. 确定分界点
   + 直接取左边界
   + 直接取右边界
   + 取中间
   + 随机
2. 调整区间
   + 区间左边的数都小于等于x，区间右边的数都大于等于x
3. 递归处理左右两段区间
   + 一次处理左边的区间，然后再处理右边的区间
   + 因为每次调用快排函数都会对其进行排序，也就是调用顺序是一直先排序左边，然后在回溯的时候再排右边

不需要开辟额外空间<使用两个指针来扫数组>

#### 算法特点
> 注意传参的边界
x为选择出来的分界点
两个指针i,j，i在左边，j在右边。
当故i的左边的数都是小于x的，j右边的数都是大于x的

### mergesort(归并排序)
#### 算法流程
1. 先把数组分成多个区间，通过多次递归区间长度的中间
2. 递归到最底部后开始回溯的时候就开始合并数组
3. 合并数组的时候在不同区间各取一个元素进行比较，把小的放先放到临时数组
4. 比较完毕后再把剩下没放完的元素放到临时数组里
5. 最后把临时数组里面的数放回原数组

#### 算法特点
1. 第一次递归是长度n的区间，第i次递归的区间则是长度n/i*2的区间
2. 每次都是logn，递归了n次，所以复杂度是nlogn

## 高精度问题
> 一般笔试可能会考
### 存储大整数
- 思路：把数的某一位存到一个数组里
   + 存储的时候第0位存个位比较好
      * 因为做进位的时候在数组末尾补上一个数比较方便
      * 普通数组要在前面添加数，所有元素都要往后移一位，在末尾添加不用移位
### 加法
#### 算法流程
- 核心思路：逐位相加（A[i] + B[i] + t）的时候要把每一位相加的结果的十位和个位分开，个位作为当前的位数，十位作为下一次计算的进位（也就是需要加到A[i+1]+B[i+1]）(这里不是累加，而是直接保存当前的进位)
> 注意区分A<=10和len(A)<=10，一个指的是数，另一个指的是位数
1. 逐位相加
2. 对于每一位来说，都是由$A_i+B_i+t$组成，t为进位。（在个位t=0,其他看情况）
3. 将$A_i+B_i+t$的结果取出其个位作为当前的位数，也就是压入数组
4. 将$A_i+B_i+t$的结果取出其十位作为下一位运算的进位

### 减法
- 核心思路：逐位相减（A[i] - B[i] - t）的时候要判断减得的结果，如果小于0则需要往前面借位，即下一次运算的时候要提前先减1，如果没有产生借位就正常计算。此时当前计算位的值为$(t+10)%10$，因为t>=0时就是t本身，t<0时那么就是借10过来，也就是在原来的基础+10即可

1. 逐位相减
2. 比较数的大小确定是否添加符号
3. 对于减法而言，如果相减不够减的时候就要向前面借一位出来
   * 从这里对比加法可以看出，每一位的组成是分两种情况：
      + 如果$A_i-B_i>=0$，则$(A_i-B_i)$
      + 如果$A_i-B_i<0$，则在原来的基础上加上10，则$(A_i-B_i+10)$
   * 对于减法而言，A和B不同的顺序会导致最后计算的值不一样，有两种情况：
      + $A-B>0$，直接减即可
      + $A-B<0$，先计算B-A，再添加负号
   * 总的来说，计算减法主要是把先计算$|A-B|$的值，再根据原来A-B的大小判断是否添加负号
4. 计算完所有位数后处理前导0。

## 二分

### 整数二分

### 浮点数二分

## 
